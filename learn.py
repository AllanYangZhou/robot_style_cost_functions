import multiprocessing
import Queue
import os
import shutil
import time

import numpy as np
import trajoptpy.math_utils as mu
from mongoengine import connect

import utils
import planners
import constants
import record_video
from ComparisonDocument import (
    Comparison,
    array_to_binary,
    binary_to_array)


KILL_TASK = 'kill'
TRAIN_TASK = 'train'
START_TASK = 'start'

num_perturbs = 5
label_batchsize = 30


def make_perturbs(x, num, perturb_amount):
    perturbed_trajs = [x]
    for j in range(num):
        delta = utils.smooth_perturb(perturb_amount)
        perturbed_trajs.append(x+delta)
    return perturbed_trajs


def generate_trajs_and_train(task_queue, traj_queue, labeled_comps_queue):
    # Must import tensorflow in child process:
    # https://github.com/tensorflow/tensorflow/issues/5448#issuecomment-258934405
    from models import CostFunction
    env, robot = utils.setup(render=True)
    monitor = record_video.get_geometry()
    cf = CostFunction(
        robot,
        use_all_links=False,
        quadratic=False)
    custom_cost = {'NN': planners.get_trajopt_cost(cf)}
    comparison_tq = utils.TrainingQueue()
    traj_counter = 0

    # Generate pretraining data
    for idcs in constants.sg_train_idcs:
        s_idx, g_idx = idcs
        q_s = constants.configs[s_idx]
        q_g = constants.configs[g_idx]
        with env:
            robot.SetActiveDOFValues(q_s)
            wps = mu.linspace2d(q_s, q_g, 10)
            perturbed_wps = make_perturbs(wps, num_perturbs, .1)
        for wps in perturbed_wps:
            with env:
                traj = utils.waypoints_to_traj(env, robot, wps, 1, None)
            out_path = 'web/vids/s{:d}-g{:d}_traj{:d}.webm'.format(
                s_idx, g_idx, traj_counter)
            record_video.record(robot, traj, out_path, monitor=monitor)
            traj_queue.put((wps, out_path, idcs))
            traj_counter += 1

    # Accumulate labeled comparisons of the pretraining trajs
    # until we reach a minimum, then continue
    print('Waiting for pretrain labels')
    while True:
        try:
            comparison = labeled_comps_queue.get(block=False)
            comparison_tq.add(comparison)
        except Queue.Empty:
            time.sleep(.5)
        if len(comparison_tq) > label_batchsize:
            break

    for _ in range(len(comparison_tq)):
        wpsA, wpsB, label = comparison_tq.sample()
        cf.train_pref(wpsA[None], wpsB[None], [label])

    # Actual main loop of this subprocess
    while True:
        try:
            next_task = task_queue.get(block=False)
            if next_task == KILL_TASK:
                print('Child process terminating.')
                break
        except Queue.Empty:
            pass
        for s_idx, g_idx in constants.sg_train_idcs:
            # Check if we've received a command
            q_s = constants.configs[s_idx]
            q_g = constants.configs[g_idx]
            with env:
                robot.SetActiveDOFValues(q_s)
                wps = planners.trajopt_simple_plan(
                    env, robot, q_g,
                    custom_costs=custom_cost,
                    joint_vel_coeff=1).GetTraj()
                perturbed_wps = make_perturbs(wps, 5, .1)
            for wps in perturbed_wps:
                out_path = 'web/vids/s{:d}-g{:d}_traj{:d}.webm'.format(
                    s_idx, g_idx, traj_counter)
                with env:
                    traj = utils.waypoints_to_traj(env, robot, wps, 1, None)
                record_video.record(robot, traj, out_path, monitor=monitor)
                traj_queue.put((wps, out_path, idcs))
                traj_counter += 1
        time.sleep(.1)


def main():
    # Directory setup
    shutil.rmtree('web/vids/')
    os.mkdir('web/vids/')

    connect('style_experiment') # mongodb connection

    # Queue to send child process commands.
    task_queue = multiprocessing.Queue()
    # Queue for receiving trajs generated by child process.
    traj_queue = multiprocessing.Queue()
    # Queue to send child labeled comparisons.
    labeled_comps_queue = multiprocessing.Queue()
    p = multiprocessing.Process(
        target=generate_trajs_and_train,
        args=[task_queue, traj_queue, labeled_comps_queue]
    )
    p.start()

    traj_tqs = {idcs: utils.TrainingQueue(maxsize=20) for idcs in constants.sg_train_idcs}
    unlabeled_comps_tq = utils.TrainingQueue()

    pretrain_trajs_generated = False
    while True:
        try:
            # Clear out traj_queue
            while True:
                wps, path, idcs = traj_queue.get(block=False)
                traj_tqs[idcs].add((wps, path))
        except Queue.Empty:
            pass

        if not pretrain_trajs_generated:
            pretrain_trajs_generated = True
            for idcs in constants.sg_train_idcs:
                if len(traj_tqs[idcs]) < (num_perturbs + 1):
                    pretrain_trajs_generated = False
            # Don't start making pairs until the pretrain traj generation is done.
            continue
        if len(Comparison.objects(label=None)) == 0:
            attempts_count = 0
            # only incremented if a comparison was successfully added.
            successes_count = 0
            while successes_count < label_batchsize and attempts_count < 100:
                attempts_count += 1
                idx = np.random.choice(len(constants.sg_train_idcs))
                idcs = constants.sg_train_idcs[idx]
                traj_tq = traj_tqs[idcs]
                (wpsA, pathA), (wpsB, pathB) = traj_tq.sample(num=2)
                if not np.allclose(wpsA, wpsB):
                    c = Comparison(
                        wpsA=array_to_binary(wpsA),
                        wpsB=array_to_binary(wpsB),
                        pathA=pathA, pathB=pathB)
                    c.save()
                    successes_count += 1
        time.sleep(.5)

    # Tell the child process to end, then join.
    task_queue.put(KILL_TASK)
    p.join()


if __name__ == '__main__':
    main()
